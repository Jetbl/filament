import "primitives/core.fil";

component Process<G>(
  @interface[G, G+1] go: 1,
  @[G, G+1] left: 32,
  @[G, G+1] right: 32,
) -> (
  @[G, G+1] out: 32,
) {
  // Internal register to save the current value
  acc := new Register[32]<G, G+2>(add.out);
  mul := new MultComb[32]<G>(left, right);
  // XXX(rachit): acc.prev is invalid in the iteration
  add := new Add[32]<G>(acc.prev, mul.out);

  out = add.out;
}

component main<G>(
  @interface[G, G+1] go: 1,
  @[G, G+1] l0: 32,
  @[G, G+1] l1: 32,
  @[G, G+1] t0: 32,
  @[G, G+1] t1: 32,
) -> (
  @[G+1, G+2] out00: 32,
  @[G+1, G+2] out01: 32,
  @[G+1, G+2] out10: 32,
  @[G+1, G+2] out11: 32,
) {

  // Systolic registers that go from left to right
  l00 := new Register[32]<G, G+2>(l0);
  l01 := new Register[32]<G, G+2>(l00.prev);
  l10 := new Register[32]<G, G+2>(l1);
  l11 := new Register[32]<G, G+2>(l10.prev);

  // Systolic registers that go from top to bottom
  t00 := new Register[32]<G, G+2>(t0);
  t10 := new Register[32]<G, G+2>(t00.prev);
  t01 := new Register[32]<G, G+2>(t1);
  t11 := new Register[32]<G, G+2>(t01.prev);

  // Connection registers to processing elements
  pe00 := new Process<G+1>(l00.out, t00.out);
  pe01 := new Process<G+1>(l01.out, t01.out);
  pe10 := new Process<G+1>(l10.out, t10.out);
  pe11 := new Process<G+1>(l11.out, t11.out);

  out00 = pe00.out;
  out01 = pe01.out;
  out10 = pe10.out;
  out11 = pe11.out;
}