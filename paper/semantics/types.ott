embed
 {{ tex-preamble
\renewcommand{\[[TEX_NAME_PREFIX]]grammartabular}[1]
  {\begin{minipage}{\columnwidth}\begin{tabular}{ll}#1\end{tabular}\end{minipage} }
\renewcommand{\[[TEX_NAME_PREFIX]]rulehead}[3]
  {$#1$  $#2$ & $#3$}
\renewcommand{\[[TEX_NAME_PREFIX]]prodline}[6]
  { \quad $#1$ \ $#2$ & \quad $#3 #4$  $#5$  $#6$}
\renewcommand{\[[TEX_NAME_PREFIX]]interrule}
  {\\[2.0mm]}
 }}

metavar x ::= {{ com variables}}
metavar M ::= {{ com components }}
metavar t ::= {{ com time variables }}
metavar n ::= {{ com naturals }}
indexvar index, i, j, k, l ::=

grammar

T :: T_ ::= {{ com time }}       {{ tex \textcolor{teal}{[[T]]} }}
  | n :: :: TimeNat                {{ com constant }}
  | inf :: :: TimeEnd              {{ com end of time }} {{ tex \infty }}
  | t  :: :: TimeVar               {{ com abstract time }}
  | n t :: :: TimeScalar           {{ com scalar time }} {{ tex [[n]]\times[[t]] }}
  | T1 + T2 :: :: TimeSum          {{ com sum }}
  {{ tex \textcolor{teal}{ [[T1]] + [[T2]] } }}
  | max ( T1 , T2 ) :: :: TimeMax  {{ com max }}

% Lifetimes
lf {{ tex \textcolor{teal}{\pi} }} :: lf_ ::= {{ com time range }}
  | [ T1 , T2 ]  :: :: LFRange  {{ com range }}
  | lf1 \/ lf2   :: :: LFUnion  {{ com union }}

% Resources
res {{ tex \rho }} :: res_ ::=
  | M ( lf )  :: :: Resource {{ com resource with lifetime }}
  {{ tex [[M]]_{ [[lf]] } }}

c :: c_ ::= {{ com  commands }}
  | def M < t > [ x1 : res1 , .. , xk : resk ] { c } :: :: CDef  {{ com definition}}
  | time t = T :: :: CTimeDef                                    {{ com time definition }}
  | x = M  :: :: CInst                                           {{ com instantiaion }}
  | invoke x ( x1 , .. , xj ) :: :: CInvoke                      {{ com invoke }}
  | when T { c } :: :: CWhen                                     {{ com timed execution }}
  {{ tex \textbf{when} \,\, [[T]] \,\, \{ [[c]] \} }}
  | c @ t :: :: CEnd                                             {{ com bind end time }}
  | c1 ; c2 :: :: CSeq                                           {{ com sequence }}
  | c1 || c2 :: :: CPar                                          {{ com parallel }}

% Types
typ {{ tex \tau }} :: typ_ ::=    {{ com types }}
  | res  :: :: Resource {{ com resource with lifetime }}
  | res [ t \ T ] :: :: TSubst  {{ com substitute }}
  | forall t . ( res1 , .. , resk ) -> ( M , tl ) :: :: TComp  {{ com component type }}

% Type store
G {{ tex \Gamma }} ::  G_  ::=            {{ com type store }}
  | { x1 : typ1 , .. , xi : typi } :: :: Gconc  {{ com concrete }}
  | { M  : typ } :: :: GDef                    {{ com component definition }}
  | ( G [ T1 , T2 ] ) :: :: GShrink             {{ com shrink }}
  {{ tex {[[G]]}_{ [ [[T1]] , [[T2]] ] } }}
  | G1 \/ G2  :: :: GUnion                      {{ com union }}
  | G1 * G2   :: :: GSepSplit                   {{ com separating split }}

% time store
sto {{ tex \Theta }} :: sto_ ::=  {{ com time store }}
  | { t1 : T1 , .. , ti : Ti } :: :: Sconc  {{ com concrete }}
  | t1 >= t2 ; sto :: :: SCons              {{ com constraint }}
  | sto >= T  :: :: SOrderAll               {{ com order all }}
  | sto1 \/ sto2 :: :: SUnion               {{ com union }}


% Styling for terminals
terminals :: 'terminals_' ::=
  | <                   ::   :: langle     {{ tex \langle }}
  | >                   ::   :: rangle     {{ tex \rangle }}
  | \/                  ::   :: setunion   {{ tex \cup }}
  | >=                  ::   :: geq        {{ tex \geq }}
  | <=                  ::   :: leq        {{ tex \leq }}
  | ->                  ::   :: rarrow     {{ tex \rightarrow }}
  | forall              ::   :: forall     {{ tex \forall }}

% Formulas that can appear in judgements
formula :: 'formula_' ::=
  | judgement ::  :: judgement  {{ com judgements }}
  | G1 = G2 :: ::  typestoreeq      {{ com type store equality }}
  | M in G  :: ::  defined          {{ com defined in type store }} {{ tex [[M]] \in [[G]] }}
  | G ( x ) = typ  :: ::  access      {{ com type store access }}
  | sto1 = sto2 :: ::  timestoreeq  {{ com time store equality }}
  | T1 >= T2 :: :: timegeq      {{ com time ordering }}
  | todo     :: :: todo         {{ com todo }} {{ tex \textbf{\textcolor{blue}{todo} } }}

defns
Jop :: '' ::=

defn
sto1 , G1 |- @ T1 c : @ T2 sto2 , G2 :: :: check :: ''
{{ tex [[sto1]] , [[G1]] \vdash_{[[T1]]} [[c]] \dashv_{[[T2]]} [[sto2]] , [[G2]] }} by

sto, G \/ {xi:resi,..,xj:resj} |-@T c :@ T + tl sto', G \/ G'
G'' = G \/ { M : forall t. (resi,..,resj) -> (M, tl) }
----------------------------- :: CheckDef
sto, G |-@T  def M<t>[xi:resi,..,xj:resj] { c } :@ T sto, G''

M in G
----------------------------- :: CheckInst
sto, G |- @ T  x = M :@T sto, G \/ { x : M ([T, inf]) }

G(x) = forall t. (res1, .., resj) -> (M, tl)
G = G' * { x1: res1[t\T], .., xj: resj[t\T] }
-------------------------------------------------- :: CheckInvoke
sto, G |- @ T invoke x(x1,..,xj) :@ T + tl sto, G'

sto, G |- @ T c1 : @ T1 sto1, G1
sto1, G1 |- @ T1 c1 : @ T2 sto2, G2
------------------------------------------------ :: CheckSeq
sto, G |- @ T c1 ; c2 : @ T2 sto2, G2

G = G1 * G2
sto, G1 |- @ T c1 : @ T1 sto1, G1'
sto, G2 |- @ T c1 : @ T2 sto2, G2'
------------------------------------------------ :: CheckPar
sto, G |- @ T c1 || c2 : @ max(T1, T2) sto, G1' \/ G2'

G1 = (G[T,T1])
G2 = (G[T1,T2])
G = G1 * G2
sto, G2 |- @ T1 c : @ T2 sto \/ sto1, G2'
G3 = (G2'[T1, inf])
sto' = sto1 >= T
------------------------------------------------ :: CheckWhen
sto, G |- @ T when T1 { c } : @ T2 sto \/ sto', G1 \/ G3


T1 >= T2
sto, G |- @ T c : @ T2 sto', G'
---------------------------------- :: Weaken
sto, G |- @ T c : @ T1 sto', G'


---------------------------- :: CheckTimeDef
sto, G |- @ T time t = T' : @ T sto \/ {t: T'} , G


sto, G |-@T c :@T' sto', G'
---------------------------- :: CheckTimeBind
sto, G |- @ T c@t : @ T' sto \/ {t: T'} , G'
