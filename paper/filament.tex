%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review,anonymous]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}

\setcopyright{none}

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}   %% For author/year citations
\usepackage{pervasives}


\begin{document}

\title{Time-Sensitive Separation Logic for Hardware Design}
% \subtitle{Subtitle}
% \subtitlenote{with subtitle note}

%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Rachit Nigam}
\affiliation{
  \institution{Cornell University}
  \country{USA}
}
\email{rnigam@cs.cornell.edu}

\author{Pedro Henrique Azevedo de Amorim}
\affiliation{
  \institution{Cornell University}
  \country{USA}
}

%% Abstract
\begin{abstract}
Write an abstract \ldots
\end{abstract}

\maketitle

\section{Introduction}

This paper describes a type system that statically proves that a circuit does not attempt to use a shared resource using multiple parallel threads of computation.
The absence of such bugs is a key requirement in proving the correctness of hardware circuits that utilize fine-grained resource sharing and reason about mutual exclusivity by reasoning about clock cycles or hardware signals.

The key idea is to use a separation logic inspired type system enriched with a notion of abstract time to enable reasoning about \emph{when} a resource is used.

\section{The Filament Language}

Filament is a core calculus for describing hardware designs that perform fine-grained resource sharing.

\subsection{Time}

Filament programs consist of \emph{components} each of which can construct and schedule the execution of other components.
Computations are scheduled using \emph{time variables} which can either be concrete or abstract.
%
\nonterms{T}
%
Scheduling using concrete time variables corresponds to defining a \emph{latency-sensitive} finite state machine that controls the execution of the hardware design using the clock signal.
On the other hand, using abstract time variables is similar to designing circuits that operate using \emph{latency-insensitive} handshake signals.
The grammar of time variables forms an algebraic \emph{ring} equipped with a top element ($\infty$).
\xxx[R]{Explain why this is a ring}

Time variables are used to define intervals.
Intervals can be used to index the type of a resource, describing when it is available.
\nonterms{lf}
\nonterms{res}

\subsection{Commands}

A Filament program consists of component definitions.
A component defines the execution schedule of other components.
A component can either instantiate components or use \emph{references} to other components
owned by the calling context.
In the former case, the component fully owns the instantiated components while
in the latter case, it is only allowed to use it for some limited amount of
time, as described by the execution schedule.

When generating hardware designs, instantiated components are declared as
submodules in the resulting HDL code while references to other components are
generated by interacting with them through signals.

\nonterms{c}

\paragraph{Component definitions.}
Components definitions provide a name and a list of references to several
component types along with their corresponding \emph{lifetimes} ($\rho$).
The lifetime of a component reference describes exactly which abstract or concrete
time intervals the reference is used for.

For example, in the following definition, the parent component \code|DoubleAdd| utilizes
the component an \code|Add| component in two intervals: $[t_0, t_1]$ and $[t_2, t_3]$:
%
\begin{lstlisting}
def DoubleAdd<t>[a: Add$_{[t_0, t_1] \cup [t_2, t_3]}$] { ... }
\end{lstlisting}
%
When attempting to check the program, the type checker needs to prove that the
two intervals are disjoint and that the concrete instance for \code|a| provided
to the module during execution is available for the required interval.

The \code|DoubleAdd| module can provide a different interface for flexibility:
%
\begin{lstlisting}
def DoubleAdd<t>[a0: Add$_{[t_0, t_1]}$, a1: Add$_{[t_2, t_3]}$] { ... }
\end{lstlisting}
%
In this case, the component uses two different adders.
By distinguishing the two adders, the component can use them in parallel.
However, if it does not use them in parallel, the definition will also allow
the calling context to \emph{use the same adder}, essentially allowing for
similar use case to the first definition.

In this way, Filament enables abstraction of hardware modules while still
admitting reasoning about the temporal use of programs.
A programmer can start with the more restrictive first definition and switch to
the second definition to express more parallelism in the design.
The Filament type system will ensure that the added parallelism in the design
does not lead to generation of hardware that has structural harzards.
Therefore Filament enforces the following high-level type safety theorem:
\emph{Well-typed programs do not have structural hazards}.

\paragraph{Instantiation and invocation}
Filament programs distinguish between the construction of hardware modules
(instantiation) and their use (invocation).
Instantiation simply makes a resource available for use in the program while
an invocation actually executes the logic defined by the module.
An invocation takes \emph{component references} which allows Filament to
represent sharing of hardware resources.

\paragraph{When statements}
When statements allow Filament to schedule the execution of logic at a particular
time.
They generalize sequential and parallel composition operators and allow
arbitrary overlap of execution schedules between components.
\xxx[R]{Show how to encode sequence and parallel using when}

\section{Type Checking}

\xxx{The current system cannot support reasoning about resources that can have
multiple, finite uses active at the \emph{same} time. For example, multi-ported
memories can allow multiple uses in the same cycle. Much like Dahlia actually
implements its reasoning through bounded linear logic instead of traditional
linear logic, we probably need to extend Filament to have some way of tracking
multiple uses of the same resource.}

\xxx[R]{Pedro says, "this might be possible to encode using a product semiring"}

The Filament type system uses a separation-logic inspired reasoning system
extended to reasoning about the timing properties of resources.

\subsection{Types}
\nonterms{typ}

Filament programs have two concrete types: resources with lifetimes and component
types.
The substitute form is only used within the type checking rules to substitute
values for free time variables within a type.
A resource with lifetime directly corresponds to the specifications provided
in a component's definition.
A component type quantifies over the start time $t$ of the component and requires
resources with the correct lifetimes to be provided.
Since Filament reasons about the execution schedules of components, a component
type returns a unit value.


\subsection{The type store}
\nonterms{G}

A type store contains bindings for resources in the current context.
Each variable maps to a concrete type which can either be a lifetime or a
component type.
There are two operations defined on time stores.
The \emph{shrink} operation intuitively limits the availability of all
resources within it to the time interval $[T_1, T_2]$ which allows the Filament
to reason about limited availability of resources.
The separating split operation corresponds to its namesake in separation logic
and splits the type store into two disjoint stores.
Two stores are disjoint if and only if there is no overlap in the lifetimes of the
resources they talk about.
Crucially, two disjoint stores can talk about the same resource as long as the
corresponding lifetimes does not overlap.

\subsection{The time store}
\nonterms{sto}

The time store contains bindings from abstract time variables to time
expressions as well as ordering constraints imposed on them.
There are two operations defines on time stores.
The union operation simply merges the bindings in two stores and the constraints
defined by them.
\xxx{what should happen if the constraints are inconsistent?}
The ``order all'' operation is used to impose an ordering constraint on all
defined time variables in a store.

\subsection{Inference Rules}

The inference rules for type checking have the form:
%
\[
\Theta_1, \Gamma_1 \vdash_{\textcolor{teal}{T}} c \dashv \Theta_2, \Gamma_2
\]
%
The rules reasons about the command $c$ at time $\textcolor{teal}{T}$ using the
time and type stores $\Theta_1$ and $\Gamma_1$ and generates the stores
$\Theta_2$ and $\Gamma_2$.

The definition rule checks the body of a component and adds a corresponding
component type to the environment.
The type store binds the lifetimes of the component references when checking
the body and discards any instantiations defined by the body after checking.
Changes to the time store are similarly discarded.
\[
\drule{CheckDef}
\]

The instantiation rule is straightforward---it simply checks if the component
being defined is bound in the context and makes it available starting at
time $\textcolor{teal}{T}$.
\[
\drule{CheckInst}
\]

The invoke rule schedules the execution of a component at time
$\textcolor{teal}{T}$.
It ensures that the context provides the concrete instances of component
references for as long as the component definition requires.
The abstract start time of the component is instantiated with the current time.
\[
\drule{CheckInvoke}
\]

The when command provides a way for programs to schedule execution of commands
at different times.
The when rule separates the context into two parts: one that contains all the
resources available before the when block executes and the remaining resources.
The command is checked starting at the specified time $\textcolor{teal}{T_1}$
under the restricted environment.
The when block may additionally instantiate abstract time variables.
The final premise ensures that variables are ordered after the start time for
the when command.
\xxx{The rule current orders things using $T$, not $T_1$. Is this correct?}
\xxx[R]{Adrian asks if it is necessary to use the projection in the suffix here. Wouldn't extracting the prefix of resources be enough?}

\[
\drule{CheckWhen}
\]

Wrap allows programs to combine multiple resources of the same type and pretend
that they are the same resource.
A wrap command takes several resources along with a lifetime specification
which need to be pairwise disjoint.
It then defines a new resource variable that is available for the union of the
specified lifetimes.
\[
\drule{CheckWrap}
\]

\xxx[R]{We can probably remove the requirement to specify the lifetimes but that would turn this into an inference problem because it is possible resources to be available in overlapping intervals causing the inference problem to take the whole program into scope of consideration for valid lifetime inference.}

The weaken rule allows us to prove statements correct when the type store that
access to resources for longer.
\[
\drule{Weaken}
\]

The time definition rule defines abstract time variables using a given time
expression.
\[
\drule{CheckTimeDef}
\]

\section{Pipeline Initiation Intervals}
Pipeline parallelism is pervasive in hardware design.
Each \emph{stage} of a pipeline can execute in parallel.
In presence of fine-grained sharing of resources, the pipeline defines an \emph{initiation interval}
which is the minimum amount of time needed before a new input can be safely processed by the pipeline.
In this section, we demonstrate how Filament can be used to prove the correctness of the initiation interval of a pipeline.

The key idea is to prove that for a pipeline $M$ with initiation interval $i$, we can execute $M$ at both time steps $t$ and $t+i$.

\section{Notes}
\begin{verbatim}
- Interface for module that returns a type L when the go signal is set to high
- Interface for module that can take an abort signal and return an approximate value
- Interface for module that merges and interleaves data
\end{verbatim}

\section{Full Semantics}
\ottmetavars
\nonterms{T,lf,res,c,typ}
\nonterms{sto, G}
\ottdefnss


%% Acknowledgments
\begin{acks}
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}


%% Bibliography
% \bibliography{./bib/papers,./bib/venues}

\end{document}
