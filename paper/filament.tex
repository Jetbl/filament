%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review,anonymous]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}

\setcopyright{none}

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}   %% For author/year citations
\usepackage{pervasives}


\begin{document}

\title{Time-Sensitive Separation Logic for Hardware Design}
% \subtitle{Subtitle}
% \subtitlenote{with subtitle note}

%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Rachit Nigam}
\affiliation{
  \institution{Cornell University}
  \country{USA}
}
\email{rnigam@cs.cornell.edu}

%% Abstract
\begin{abstract}
Write an abstract \ldots
\end{abstract}

\maketitle

\section{Introduction}

This paper describes a type system that statically proves that a circuit does not attempt to use a shared resource using multiple parallel threads of computation.
The absence of such bugs is a key requirement in proving the correctness of hardware circuits that utilize fine-grained resource sharing and reason about mutual exclusivity by reasoning about clock cycles or hardware signals.

The key idea is to use a separation logic inspired type system enriched with a notion of abstract time to enable reasoning about \emph{when} a resource is used.

\section{The Filament Language}

Filament is a core calculus for describing hardware designs that perform fine-grained resource sharing.
Filament programs consist of \emph{components} each of which can construct and schedule the execution of other components.
Computations are scheduled using \emph{time variables} which can either be concrete or abstract.
%
\nonterms{T}
%
Scheduling using concrete time variables corresponds to defining a \emph{latency-sensitive} finite state machine that controls the execution of the hardware design using the clock signal.
On the other hand, using abstract time variables is similar to designing circuits that operate using \emph{latency-insensitive} handshake signals.
The grammar of time variables forms an algebraic \emph{ring} equipped with a top element ($\infty$).
\xxx[R]{Explain why this is a ring}

Time variables are used to define intervals.
Intervals can be used to index the type of a resource, describing when it is available.
\nonterms{lf}
\nonterms{res}

\subsection{Commands}

A Filament program consists of component definitions.
A component defines the execution schedule of other components.
A component can either instantiate components or use \emph{references} to other components
owned by the calling context.
In the former case, the component fully owns the instantiated components while
in the latter case, it is only allowed to use it for some limited amount of
time, as described by the execution schedule.

When generating hardware designs, instantiated components are declared as
submodules in the resulting HDL code while references to other components are
generated by interacting with them through signals.

\nonterms{c}

\paragraph{Component definitions.}
Components definitions provide a name and a list of references to several
component types along with their corresponding \emph{lifetimes} ($\rho$).
The lifetime of a component reference describes exactly which abstract or concrete
time intervals the reference is used for.

For example, in the following definition, the parent component \code|DoubleAdd| utilizes
the component an \code|Add| component in two intervals: $[t_0, t_1]$ and $[t_2, t_3]$:
%
\begin{lstlisting}
def DoubleAdd<t>[a: Add$_{[t_0, t_1] \cup [t_2, t_3]}$] { ... }
\end{lstlisting}
%
When attempting to check the program, the type checker needs to prove that the
two intervals are disjoint and that the concrete instance for \code|a| provided
to the module during execution is available for the required interval.

The \code|DoubleAdd| module can provide a different interface for flexibility:
%
\begin{lstlisting}
def DoubleAdd<t>[a0: Add$_{[t_0, t_1]}$, a1: Add$_{[t_2, t_3]}$] { ... }
\end{lstlisting}
%
In this case, the component uses two different adders.
By distinguishing the two adders, the component can use them in parallel.
However, if it does not use them in parallel, the definition will also allow
the calling context to \emph{use the same adder}, essentially allowing for
similar use case to the first definition.

In this way, Filament enables abstraction of hardware modules while still
admitting reasoning about the temporal use of programs.
A programmer can start with the more restrictive first definition and switch to
the second definition to express more parallelism in the design.
The Filament type system will ensure that the added parallelism in the design
does not lead to generation of hardware that has structural harzards.
Therefore Filament enforces the following high-level type safety theorem:
\emph{Well-typed programs do not have structural hazards}.

\section{Type Checking}

The Filament type system uses a separation-logic inspired reasoning system
extended to reasoning about the timing properties of resources.

\nonterms{typ}

\paragraph{The type store}
\nonterms{G}

\paragraph{The time store}
\nonterms{sto}

\ottdefncheck

\section{Pipeline Initiation Intervals}
Pipeline parallelism is pervasive in hardware design.
Each \emph{stage} of a pipeline can execute in parallel.
In presence of fine-grained sharing of resources, the pipeline defines an \emph{initiation interval}
which is the minimum amount of time needed before a new input can be safely processed by the pipeline.
In this section, we demonstrate how Filament can be used to prove the correctness of the initiation interval of a pipeline.

The key idea is to prove that for a pipeline $M$ with initiation interval $i$, we can execute $M$ at both time steps $t$ and $t+i$.

\section{Notes}
\begin{verbatim}
- Interface for module that returns a type L when the go signal is set to high
- Interface for module that can take an abort signal and return an approximate value
- Interface for module that merges and interleaves data
\end{verbatim}


%% Acknowledgments
\begin{acks}
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}


%% Bibliography
% \bibliography{./bib/papers,./bib/venues}

\end{document}
