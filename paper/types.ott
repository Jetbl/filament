embed
 {{ tex-preamble
\renewcommand{\[[TEX_NAME_PREFIX]]grammartabular}[1]
  {\begin{minipage}{\columnwidth}\begin{tabular}{ll}#1\end{tabular}\end{minipage} }
\renewcommand{\[[TEX_NAME_PREFIX]]rulehead}[3]
  {$#1$  $#2$ & $#3$}
\renewcommand{\[[TEX_NAME_PREFIX]]prodline}[6]
  { \quad $#1$ \ $#2$ & \quad $#3 #4$  $#5$  $#6$}
\renewcommand{\[[TEX_NAME_PREFIX]]interrule}
  {\\[2.0mm]}
 }}

metavar x ::= {{ com variables}}
metavar M ::= {{ com components }}
metavar t ::= {{ com time variables }}
metavar sto ::= {{ com time store }} {{ tex \Theta }}
metavar n ::= {{ com naturals }}
indexvar index, j, k, l ::=

grammar

T :: T_ ::= {{ com time }}       {{ tex \textcolor{red}{[[T]]} }}
  | n :: :: TimeNat                {{ com constant }}
  | t  :: :: TimeVar               {{ com abstract time }}
  | n t :: :: TimeScalar           {{ com scalar time }} {{ tex [[n]]\times[[t]] }}
  | T1 + T2 :: :: TimeSum          {{ com sum }}
  | max ( T1 , T2 ) :: :: TimeMax  {{ com max }}

c :: c_ ::= {{ com  commands }}
  | def M < t > [ M1 , .. , Mj ] ( & Mk , .. , & Ml ) :: :: CDef      {{ com definition}}
  | x = M [ M1 , .. , Mj ] :: :: CInst           {{ com instantiaion }}
  | invoke M ( & x1 , .. , & xj ) :: :: CInvoke  {{ com invoke }}
  | when T { c } :: :: CWhen
  {{ com timed execution }}
  {{ tex \textbf{when} \,\, [[T]] \,\, \{ [[c]] \} }}
  | c @ t :: :: CEnd            {{ com bind end time }}
  | c1 ; c2 :: :: CSeq  {{ com sequence }}
  | c1 || c2 :: :: CPar {{ com parallel }}

G {{ tex \Gamma }} ::  G_  ::=  {{ com type store }}
    | empty :: :: GEmp  {{ com empty }} {{ tex \cdot }}
    | x : M [ T1 , T2 ] ; G :: :: GExt
    {{ com extend }}
    {{ tex [[x]] : [[M]]_{ [ [[T1]] , [[T2]] ] } ; [[G]] }}
    | ( G [ T1 , T2 ] ) :: :: GShrink
    {{ com shrink }}
    {{ tex [[G]]_{ [ [[T1]] , [[T2]] ] } }}
    | G1 \/ G2  :: :: GUnion  {{ com union }}
    | G1 * G2   :: :: GSepSplit {{ com separating split }}

terminals :: 'terminals_' ::=
  | <                   ::   :: langle     {{ tex \langle }}
  | >                   ::   :: rangle     {{ tex \rangle }}
  | \/                  ::   :: setunion   {{ tex \cup }}

formula :: 'formula_' ::=
  | judgement ::  :: judgement
  | G1 = G2 :: ::  storeeq
  | T1 > T2 :: :: timegeq  {{ tex [[T1]] \, $>$ \, [[T2]] }}

defns
Jop :: '' ::=

defn
sto , G1 @ T1 |- c : @ T2 G2 :: :: check :: ''
{{ tex [[sto]] , [[G1]] \vdash_{[[T1]]} [[c]] \dashv_{[[T2]]} [[G2]] }} by

sto, G @ T |- c1 : @ T1 G1
sto, G1 @ T1 |- c1 : @ T2 G2
------------------------------------------------ :: check_seq
sto, G @ T |- c1 ; c2 : @ T2 G2

G = G1 * G2
sto, G1 @ T |- c1 : @ T1 G1'
sto, G2 @ T |- c1 : @ T2 G2'
------------------------------------------------ :: check_par
sto, G @ T |- c1 || c2 : @ max(T1, T2) G1' \/ G2'

G1 = (G[T,T1])
G2 = (G[T1,T2])
G = G1 * G2
sto, G2 @ T1 |- c : @ T2 G2'
------------------------------------------------ :: check_when
sto, G @ T |- when T1 { c } : @ T2 G1 \/ G2'


T1 > T2
sto, G @ T |- c : @ T2 G'
---------------------------------- :: check_weaken
sto, G @ T |- c : @ T1 G'


 % defn
 % e1 --> e2 :: ::reduce:: ''  {{ tex [[e1]] \longrightarrow [[e2]] }} by


 %    --------------------------  :: ax_app
 %    (\x.e1) v2 -->  {v2/x}e1

 %    e1 --> e1'
 %    -------------- :: ctx_app_fun
 %    e1 e --> e1' e

 %    e1 --> e1'
 %    -------------- :: ctx_app_arg
 %    v e1 --> v e1'
